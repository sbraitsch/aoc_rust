use std::ops::RangeInclusive;

use crate::utils;
use proctor::timed;

// Stub generated by Elf
pub fn solve() {
    let lines = utils::file_to_lines("2021", "05");
    part_one(&lines);
    part_two(&lines);
}

#[timed]
fn part_one(lines: &[String]) -> usize {
    fill_chart(lines, false)
}

#[timed]
fn part_two(lines: &[String]) -> usize {
    fill_chart(lines, true)
}

fn fill_chart(lines: &[String], p2: bool) -> usize {
    let mut chart = vec![vec![0; 999]; 999];
    lines.iter().for_each(|line| {
        if let Some((first, second)) = line.split_once(" -> ") {
            let (f1, f2) = parse_tuple(first);
            let (s1, s2) = parse_tuple(second);
            if f1 == s1 {
                for idx in get_range(f2, s2) {
                    chart[idx][f1] += 1;
                }
            } else if f2 == s2 {
                for idx in get_range(f1, s1) {
                    chart[f2][idx] += 1;
                }
            } else if p2 {
                for (x, y) in get_range(f1, s1).zip(get_range(f2, s2)) {
                    chart[y][x] += 1;
                }
            }
        }
    });

    chart
        .into_iter()
        .map(|row| row.into_iter().filter(|v| v > &1).count())
        .sum()
}

fn parse_tuple(second: &str) -> (usize, usize) {
    second
        .split_once(",")
        .map(|(a, b)| (a.parse::<usize>().unwrap(), b.parse::<usize>().unwrap()))
        .unwrap()
}

fn get_range(a: usize, b: usize) -> Box<dyn Iterator<Item = usize>> {
    return match a.cmp(&b) {
        std::cmp::Ordering::Less | std::cmp::Ordering::Equal => Box::new(a..=b),
        std::cmp::Ordering::Greater => Box::new((b..=a).rev()),
    };
}
