use crate::utils;
use std::collections::{HashMap, HashSet};
use std::time::Instant;

type ParsedPuzzle = (HashMap<char, Vec<(usize, usize)>>, (isize, isize));

fn parse_input(lines: Vec<String>) -> ParsedPuzzle {
    let mut search_cache: HashMap<char, Vec<(usize, usize)>> = HashMap::new();
    let x_dim = lines[0].len() as isize;
    let y_dim = lines.len() as isize;
    lines.into_iter().enumerate().for_each(|(y, line)| {
        line.chars().enumerate().for_each(|(x, c)| {
            if c != '.' {
                search_cache
                    .entry(c)
                    .and_modify(|v| v.push((x, y)))
                    .or_insert(vec![(x, y)]);
            }
        })
    });
    (search_cache, (x_dim, y_dim))
}

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let (cache, bounds) = parse_input(utils::file_to_lines("2024", "08"));
    let mut time = Instant::now();
    let p1 = part_one(&cache, bounds);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&cache, bounds);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(cache: &HashMap<char, Vec<(usize, usize)>>, bounds: (isize, isize)) -> usize {
    let mut antinodes: HashSet<(isize, isize)> = HashSet::new();
    cache.iter().for_each(|(_, v)| {
        v.iter().enumerate().for_each(|(i, &(ax, ay))| {
            v.iter().enumerate().for_each(|(j, &(bx, by))| {
                if i != j {
                    let cx = bx as isize + (bx as isize - ax as isize);
                    let cy = by as isize + (by as isize - ay as isize);

                    if !(cx < 0 || cy < 0 || cx >= bounds.0 || cy >= bounds.1) {
                        antinodes.insert((cx, cy));
                    }
                }
            });
        });
    });

    antinodes.len()
}
fn part_two(cache: &HashMap<char, Vec<(usize, usize)>>, bounds: (isize, isize)) -> usize {
    let mut antinodes: HashSet<(isize, isize)> = HashSet::new();
    cache.iter().for_each(|(_, v)| {
        v.iter().enumerate().for_each(|(i, &(ax, ay))| {
            v.iter().enumerate().for_each(|(j, &(bx, by))| {
                antinodes.insert((ax as isize, ay as isize));
                if i != j {
                    let d_x = bx as isize - ax as isize;
                    let d_y = by as isize - ay as isize;

                    let mut cx = bx as isize + d_x;
                    let mut cy = by as isize + d_y;

                    while !(cx < 0 || cy < 0 || cx >= bounds.0 || cy >= bounds.1) {
                        antinodes.insert((cx, cy));
                        cx += d_x;
                        cy += d_y;
                    }
                }
            });
        });
    });

    antinodes.len()
}
