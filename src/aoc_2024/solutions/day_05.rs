use once_cell::sync::Lazy;

use crate::utils;
use std::cmp::Ordering;
use std::sync::Mutex;
use std::time::Instant;

#[derive(Eq, PartialEq)]
struct Page(usize);

static RULES: Lazy<Mutex<Vec<(usize, usize)>>> = Lazy::new(|| Mutex::new(Vec::new()));

impl Ord for Page {
    fn cmp(&self, other: &Self) -> Ordering {
        let rules = RULES.lock().unwrap();
        for &(first, second) in rules.iter() {
            if self.0 == first && other.0 == second {
                return Ordering::Less;
            }
            if self.0 == second && other.0 == first {
                return Ordering::Greater;
            }
        }
        Ordering::Equal
    }
}

impl PartialOrd for Page {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn parse_input(input: &str) -> Vec<Vec<Page>> {
    let sections: Vec<&str> = input.split("\n\n").collect();

    let rules: Vec<(usize, usize)> = sections[0]
        .lines()
        .map(|line| {
            let mut parts = line.split('|');
            let a = parts.next().unwrap().parse::<usize>().unwrap();
            let b = parts.next().unwrap().parse::<usize>().unwrap();
            (a, b)
        })
        .collect();

    {
        let mut lazy = RULES.lock().unwrap();
        *lazy = rules.clone();
    }

    let updates: Vec<Vec<Page>> = sections[1]
        .lines()
        .map(|line| {
            line.split(',')
                .map(|num| Page(num.parse::<usize>().unwrap()))
                .collect()
        })
        .collect();
    updates
}

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let input = utils::file_to_string("2024", "05");
    let mut time = Instant::now();
    let (sorted, mut unsorted) = parse_input(&input).into_iter().partition(|u| u.is_sorted());
    let p1 = part_one(&sorted);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&mut unsorted);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(sorted: &Vec<Vec<Page>>) -> usize {
    sorted
        .iter()
        .map(|update| update[(update.len() - 1) / 2].0)
        .sum()
}
fn part_two(unsorted: &mut Vec<Vec<Page>>) -> usize {
    unsorted
        .iter_mut()
        .map(|update| {
            update.sort_unstable();
            update[(update.len() - 1) / 2].0
        })
        .sum()
}
