use once_cell::sync::Lazy;
use std::collections::HashMap;

use crate::utils;
use std::cmp::Ordering;
use std::sync::Mutex;
use std::time::Instant;

#[derive(Debug, Eq, PartialEq)]
struct Page(usize);

static RULES: Lazy<Mutex<HashMap<usize, Vec<usize>>>> = Lazy::new(|| Mutex::new(HashMap::new()));

impl Ord for Page {
    fn cmp(&self, other: &Self) -> Ordering {
        let rules = RULES.lock().unwrap();
        if let Some(mapped) = rules.get(&self.0) {
            if mapped.contains(&other.0) {
                return Ordering::Less;
            }
        }
        if let Some(mapped) = rules.get(&other.0) {
            if mapped.contains(&self.0) {
                return Ordering::Greater;
            }
        }
        Ordering::Equal
    }
}

impl PartialOrd for Page {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

fn parse_input(input: &str) -> Vec<Vec<Page>> {
    let sections: Vec<&str> = input.split("\n\n").collect();

    let rules: HashMap<usize, Vec<usize>> =
        sections[0].lines().fold(HashMap::new(), |mut hm, line| {
            let mut parts = line.split('|');
            let a = parts.next().unwrap().parse::<usize>().unwrap();
            let b = parts.next().unwrap().parse::<usize>().unwrap();
            hm.entry(a).and_modify(|v| v.push(b)).or_insert(vec![b]);
            hm
        });
    {
        let mut lazy = RULES.lock().unwrap();
        *lazy = rules;
    }

    let updates: Vec<Vec<Page>> = sections[1]
        .lines()
        .map(|line| {
            line.split(',')
                .map(|num| Page(num.parse::<usize>().unwrap()))
                .collect()
        })
        .collect();
    updates
}

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let input = utils::file_to_string("2024", "05");
    let mut time = Instant::now();
    let (sorted, mut unsorted) = parse_input(&input).into_iter().partition(|u| u.is_sorted());
    let p1 = part_one(&sorted);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&mut unsorted);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(sorted: &Vec<Vec<Page>>) -> usize {
    sorted
        .iter()
        .map(|update| update[(update.len() - 1) / 2].0)
        .sum()
}
fn part_two(unsorted: &mut Vec<Vec<Page>>) -> usize {
    unsorted
        .iter_mut()
        .map(|update| {
            update.sort_unstable();
            update[(update.len() - 1) / 2].0
        })
        .sum()
}
