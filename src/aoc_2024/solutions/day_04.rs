use crate::utils;
use std::time::Instant;

const DIRECTIONS: [(i32, i32); 8] = [
    (0, 1),   // Right
    (0, -1),  // Left
    (1, 0),   // Down
    (-1, 0),  // Up
    (1, 1),   // Down-right diagonal
    (1, -1),  // Down-left diagonal
    (-1, 1),  // Up-right diagonal
    (-1, -1), // Up-left diagonal
];

const WORD: &str = "XMAS";

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let lines = utils::file_to_lines("2024", "04");
    let mut time = Instant::now();
    let p1 = part_one(&lines);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&lines);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(lines: &[String]) -> usize {
    lines
        .iter()
        .enumerate()
        .map(|(y, line)| {
            line.chars()
                .enumerate()
                .map(|(x, c)| {
                    if c == 'X' {
                        check_for_xmas(lines, (x, y), lines.len(), line.len())
                    } else {
                        0
                    }
                })
                .sum::<usize>()
        })
        .sum()
}

fn part_two(lines: &[String]) -> usize {
    lines
        .iter()
        .enumerate()
        .map(|(y, line)| {
            if !(y == 0 || y == lines.len() - 1) {
                line.chars()
                    .enumerate()
                    .map(|(x, c)| {
                        if x != 0 && x != line.len() - 1 && c == 'A' {
                            check_for_x_mas(lines, (x, y))
                        } else {
                            0
                        }
                    })
                    .sum::<usize>()
            } else {
                0
            }
        })
        .sum()
}

fn check_for_xmas(lines: &[String], (x, y): (usize, usize), rows: usize, cols: usize) -> usize {
    DIRECTIONS
        .iter()
        .map(|&(dir_x, dir_y)| {
            let mut valid = true;

            for i in 1..WORD.len() {
                let next_x = x as i32 + dir_x * i as i32;
                let next_y = y as i32 + dir_y * i as i32;

                if next_x < 0 || next_x >= cols as i32 || next_y < 0 || next_y >= rows as i32 {
                    valid = false;
                    break;
                }

                if lines[next_y as usize].chars().nth(next_x as usize) != WORD.chars().nth(i) {
                    valid = false;
                    break;
                }
            }
            valid as usize
        })
        .sum()
}

fn check_for_x_mas(lines: &[String], (x, y): (usize, usize)) -> usize {
    let top_left = lines[y - 1].chars().nth(x - 1).unwrap();
    let top_right = lines[y - 1].chars().nth(x + 1).unwrap();
    let bot_left = lines[y + 1].chars().nth(x - 1).unwrap();
    let bot_right = lines[y + 1].chars().nth(x + 1).unwrap();
    
    (((top_left == 'M' && bot_right == 'S') || (top_left == 'S' && bot_right == 'M')) && ((bot_left == 'M' && top_right == 'S') || (bot_left == 'S' && top_right == 'M'))) as usize
}
