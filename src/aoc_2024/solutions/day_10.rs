use crate::utils;
use std::{collections::HashSet, time::Instant};

fn parse_input(lines: &[String]) -> Vec<Vec<u32>> {
    lines
        .iter()
        .map(|line| {
            line.chars()
                .filter_map(|c| c.to_digit(10))
                .collect::<Vec<u32>>()
        })
        .collect()
}

fn collect_trails(grid: &[Vec<u32>], collect_all_distinct: bool) -> usize {
    grid.iter()
        .enumerate()
        .map(|(y, row)| {
            row.iter()
                .enumerate()
                .map(|(x, &elevation)| {
                    if elevation == 0 {
                        find_trails(grid, (x, y, elevation), &mut HashSet::new(), collect_all_distinct)
                    } else {
                        0
                    }
                })
                .sum::<usize>()
        })
        .sum()

}

fn find_trails(
    grid: &[Vec<u32>],
    (x, y, elevation): (usize, usize, u32),
    visited: &mut HashSet<(usize, usize)>,
    all_distinct: bool,
) -> usize {
    if elevation == 9 {
        if !all_distinct {
            return visited.insert((x, y)) as usize;
        } else {
            return 1;
        }
    }

    let mut res = 0;
    if x > 0 {
        let next = grid[y][x - 1];
        if next == (elevation + 1) {
            res += find_trails(grid, (x - 1, y, next), visited, all_distinct);
        }
    }
    if x < grid[0].len() - 1 {
        let next = grid[y][x + 1];
        if next == (elevation + 1) {
            res += find_trails(grid, (x + 1, y, next), visited, all_distinct);
        }
    }
    if y > 0 {
        let next = grid[y - 1][x];
        if next == (elevation + 1) {
            res += find_trails(grid, (x, y - 1, next), visited, all_distinct);
        }
    }
    if y < grid.len() - 1 {
        let next = grid[y + 1][x];
        if next == (elevation + 1) {
            res += find_trails(grid, (x, y + 1, next), visited, all_distinct);
        }
    }
    res
}

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let lines = utils::file_to_lines("2024", "10");
    let grid = parse_input(&lines);
    let mut time = Instant::now();
    let p1 = part_one(&grid);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&grid);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(grid: &[Vec<u32>]) -> usize {
    collect_trails(grid, false)
}
fn part_two(grid: &[Vec<u32>]) -> usize {
    collect_trails(grid, true)
}
