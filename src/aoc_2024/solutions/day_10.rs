use crate::{grid::Grid, utils};
use std::{collections::HashSet, time::Instant};

fn collect_trails(grid: &Grid<u32>, collect_all_distinct: bool) -> usize {
    grid.iter()
        .map(|((x, y), opt_e)| {
            if let Some(&elevation) = opt_e {
                if elevation == 0 {
                    let opt_set = if collect_all_distinct {
                        &mut Some(HashSet::<(usize, usize)>::new())
                    } else {
                        &mut None
                    };
                    return find_trails(grid, ((x, y), &elevation), opt_set);
                }
            }
            0
        })
        .sum()
}

fn find_trails(
    grid: &Grid<u32>,
    ((x, y), elevation): ((usize, usize), &u32),
    opt_vis: &mut Option<HashSet<(usize, usize)>>,
) -> usize {
    if *elevation == 9 {
        match opt_vis.as_mut() {
            Some(v) => return v.insert((x, y)) as usize,
            _ => return 1,
        }
    }

    let mut res = 0;
    for adj in grid.adjacent((x, y), false) {
        if *adj.1 == elevation + 1 {
            res += find_trails(grid, adj, opt_vis);
        }
    }
    res
}

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let grid = Grid::parse(&utils::file_to_lines("2024", "10"), |c| c.to_digit(10).unwrap());
    let mut time = Instant::now();
    let p1 = part_one(&grid);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&grid);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(grid: &Grid<u32>) -> usize {
    collect_trails(grid, true)
}
fn part_two(grid: &Grid<u32>) -> usize {
    collect_trails(grid, false)
}
