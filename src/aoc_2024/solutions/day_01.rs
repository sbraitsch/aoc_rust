use crate::utils;
use std::collections::{BinaryHeap, HashMap};
use std::time::Instant;

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let lines = utils::file_to_lines("2024", "01");
    let mut time = Instant::now();
    let p1 = part_one(&lines);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&lines);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(lines: &[String]) -> usize {
    let mut left_vec = Vec::new();
    let mut right_vec = Vec::new();

    lines.iter().for_each(|line| {
        if let Some((a, b)) = line.split_once("   ") {
            if let (Ok(num_a), Ok(num_b)) = (a.parse::<usize>(), b.parse::<usize>()) {
                left_vec.push(num_a);
                right_vec.push(num_b);
            }
        }
    });

    left_vec.sort();
    right_vec.sort();

    (0..left_vec.len()).fold(0usize, |acc, i| acc + left_vec[i].abs_diff(right_vec[i]))
}

fn part_two(lines: &[String]) -> usize {
    let mut left_side: Vec<usize> = Vec::new();
    let mut right_side_freq: HashMap<usize, usize> = HashMap::new();

    lines.iter().for_each(|line| {
        let mut split = line.split_whitespace();
        left_side.push(split.next().unwrap().parse::<usize>().unwrap());
        let r = split.next().unwrap().parse::<usize>().unwrap();
        right_side_freq
            .entry(r)
            .and_modify(|r| *r += 1)
            .or_insert(1);
    });

    let res = left_side.iter().fold(0usize, |acc, id| {
        acc + (id * right_side_freq.get(id).unwrap_or(&0))
    });

    res
}
