use crate::utils;
use std::collections::{BinaryHeap, HashMap};
use std::hash::Hash;
use std::time::Instant;

// Stub generated by Elf
pub fn solve() {
    // elf splits the printed output at the first <space> and takes writes the first half as the solution
    let lines = utils::file_to_lines("2024", "01");
    let mut time = Instant::now();
    let p1 = part_one(&lines);
    println!("{:?} in {:?} for Part 1", p1, time.elapsed());
    time = Instant::now();
    let p2 = part_two(&lines);
    println!("{:?} in {:?} for Part 2", p2, time.elapsed());
}

fn part_one(lines: &[String]) -> usize {
    let mut left_heap = BinaryHeap::new();
    let mut right_heap = BinaryHeap::new();

    lines.into_iter().for_each(|line| {
        let mut split = line.split_whitespace();
        left_heap.push(split.next().unwrap().parse::<usize>().unwrap());
        right_heap.push(split.next().unwrap().parse::<usize>().unwrap());
    });
    let res = (0..left_heap.len()).into_iter().fold(0usize, |acc, _| {
        acc + left_heap.pop().unwrap().abs_diff(right_heap.pop().unwrap())
    });
    res
}
fn part_two(lines: &[String]) -> usize {
    let mut left_side: Vec<usize> = Vec::new();
    let mut right_side_freq: HashMap<usize, usize> = HashMap::new();

    lines.into_iter().for_each(|line| {
        let mut split = line.split_whitespace();
        left_side.push(split.next().unwrap().parse::<usize>().unwrap());
        let r = split.next().unwrap().parse::<usize>().unwrap();
        right_side_freq
            .entry(r)
            .and_modify(|r| *r += 1)
            .or_insert(1);
    });

    let res = left_side.iter().fold(0usize, |mut acc, id| {
        acc + (id * right_side_freq.get(id).unwrap_or(&0))
    });

    res
}
